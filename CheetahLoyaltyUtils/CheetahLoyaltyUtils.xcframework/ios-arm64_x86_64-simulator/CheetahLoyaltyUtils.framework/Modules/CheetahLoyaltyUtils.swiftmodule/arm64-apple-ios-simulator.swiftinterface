// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name CheetahLoyaltyUtils
@_exported import CheetahLoyaltyUtils
import Foundation
import LocalAuthentication
import MobileCoreServices
import Swift
import SystemConfiguration
import UIKit
extension Result {
  public var isSuccess: Swift.Bool {
    get
  }
  public var isFailure: Swift.Bool {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Swift.Error? {
    get
  }
}
extension Result : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Result : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum HTTPMethod : Swift.String {
  case delete
  case get
  case patch
  case post
  case put
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public typealias HTTPHeaders = [Swift.String : Swift.String]
public typealias Parameters = [Swift.String : Any]
public struct MultipartAttachment : Swift.Equatable {
  public let name: Swift.String
  public let fileName: Swift.String?
  public let url: Foundation.URL?
  public let data: Foundation.Data?
  public var mimeType: Swift.String?
  public init(name: Swift.String, fileName: Swift.String? = nil, url: Foundation.URL? = nil, data: Foundation.Data? = nil, mimeType: Swift.String? = nil)
  public static func == (a: CheetahLoyaltyUtils.MultipartAttachment, b: CheetahLoyaltyUtils.MultipartAttachment) -> Swift.Bool
}
public typealias MultipartAttachments = [CheetahLoyaltyUtils.MultipartAttachment]
public enum ParameterEncoding {
  case urlEncodedForm
  case json
  public static func == (a: CheetahLoyaltyUtils.ParameterEncoding, b: CheetahLoyaltyUtils.ParameterEncoding) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum URLError : Swift.Error {
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
  }
  case invalidURL(url: CheetahLoyaltyUtils.URLConvertible)
  case parameterEncodingFailed(reason: CheetahLoyaltyUtils.URLError.ParameterEncodingFailureReason)
}
extension URLError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension URLRequest {
  public init(url: CheetahLoyaltyUtils.URLConvertible, method: CheetahLoyaltyUtils.HTTPMethod, headers: CheetahLoyaltyUtils.HTTPHeaders? = nil) throws
  public init(url: CheetahLoyaltyUtils.URLConvertible, method: CheetahLoyaltyUtils.HTTPMethod, headers: CheetahLoyaltyUtils.HTTPHeaders? = nil, parameters: CheetahLoyaltyUtils.Parameters?, multipartAttachments: CheetahLoyaltyUtils.MultipartAttachments? = nil, encoding: CheetahLoyaltyUtils.ParameterEncoding = .urlEncodedForm) throws
  public mutating func encode(with parameters: CheetahLoyaltyUtils.Parameters?, encoding: CheetahLoyaltyUtils.ParameterEncoding = .urlEncodedForm) throws
  public static func encode(_ urlRequest: inout Foundation.URLRequest, with parameters: CheetahLoyaltyUtils.Parameters?, encoding: CheetahLoyaltyUtils.ParameterEncoding = .urlEncodedForm) throws
}
extension URL {
  public static let defaultBinaryMimeType: Swift.String
  public var mimeType: Swift.String {
    get
  }
}
public protocol CheetahNotification {
  var name: Swift.String { get }
}
extension Notification {
  public init(_ notification: CheetahLoyaltyUtils.CheetahNotification, object: Any? = nil, userInfo: [Swift.AnyHashable : Any]? = nil)
}
extension NotificationCenter {
  public func addObserver(for notification: CheetahLoyaltyUtils.CheetahNotification, object: Any?, queue: Foundation.OperationQueue?, using: @escaping (Foundation.Notification) -> Swift.Void) -> ObjectiveC.NSObjectProtocol
}
public enum UtilsNotification : CheetahLoyaltyUtils.CheetahNotification {
  case languageChange
  public var name: Swift.String {
    get
  }
  public static func == (a: CheetahLoyaltyUtils.UtilsNotification, b: CheetahLoyaltyUtils.UtilsNotification) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension KeyedDecodingContainer {
  public func decode<T>(forKey key: K, defaultValue: T) throws -> T where T : Swift.Decodable
}
public protocol URLRequestConvertible {
  var path: Swift.String { get }
  var method: CheetahLoyaltyUtils.HTTPMethod { get }
  var parameters: CheetahLoyaltyUtils.Parameters? { get }
  var headers: CheetahLoyaltyUtils.HTTPHeaders? { get }
  var multipartAttachments: CheetahLoyaltyUtils.MultipartAttachments? { get }
  var parameterEncoding: CheetahLoyaltyUtils.ParameterEncoding { get }
  func asURLRequest(path updatePath: Swift.String?, headers additionalHeaders: CheetahLoyaltyUtils.HTTPHeaders, parameters additionalParameters: CheetahLoyaltyUtils.Parameters, attachments additionalAttachments: CheetahLoyaltyUtils.MultipartAttachments) throws -> Foundation.URLRequest
}
extension URLRequestConvertible {
  public var headers: CheetahLoyaltyUtils.HTTPHeaders? {
    get
  }
  public var path: Swift.String {
    get
  }
  public var method: CheetahLoyaltyUtils.HTTPMethod {
    get
  }
  public var parameters: CheetahLoyaltyUtils.Parameters? {
    get
  }
  public var multipartAttachments: CheetahLoyaltyUtils.MultipartAttachments? {
    get
  }
  public var parameterEncoding: CheetahLoyaltyUtils.ParameterEncoding {
    get
  }
  public func asURLRequest(path updatePath: Swift.String? = nil, headers additionalHeaders: CheetahLoyaltyUtils.HTTPHeaders = [:], parameters additionalParameters: CheetahLoyaltyUtils.Parameters = [:], attachments additionalAttachments: CheetahLoyaltyUtils.MultipartAttachments = []) throws -> Foundation.URLRequest
}
extension URLRequest : CheetahLoyaltyUtils.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension String : CheetahLoyaltyUtils.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URL : CheetahLoyaltyUtils.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Encodable {
  public var json: [Swift.String : Any] {
    get
  }
}
extension Data {
  public var hexString: Swift.String {
    get
  }
  public func serializedJsonObject(options: Foundation.JSONSerialization.ReadingOptions = .allowFragments) -> Any?
}
extension Dictionary where Key == Swift.String, Value == Any {
  public func filterVoid() -> [Swift.String : Any]
}
extension Date {
  public static func dateFrom(string: Swift.String, withFormat format: Swift.String) -> Foundation.Date?
  public func string(withFormat format: Swift.String, locale: Foundation.Locale? = nil) -> Swift.String
  public func localizedString(withFormat format: Swift.String) -> Swift.String
  public func formattedStringWithDate(showDate: Swift.Bool, showTime: Swift.Bool, timeZone: Foundation.TimeZone = .current) -> Swift.String?
  public func numberOfYears(fromDate date: Foundation.Date) -> Swift.Int?
}
extension UIImage {
  public func compressedImage(compressRatio: CoreGraphics.CGFloat, maxCompressRatio: CoreGraphics.CGFloat = 0.1) -> UIKit.UIImage
  public func scaledDownImage(to size: CoreGraphics.CGSize) -> UIKit.UIImage?
}
public struct AnyEncodable : Swift.Encodable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension AnyEncodable : Swift.Equatable {
  public static func == (lhs: CheetahLoyaltyUtils.AnyEncodable, rhs: CheetahLoyaltyUtils.AnyEncodable) -> Swift.Bool
}
extension AnyEncodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyEncodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AnyEncodable : Swift.ExpressibleByNilLiteral, Swift.ExpressibleByBooleanLiteral, Swift.ExpressibleByIntegerLiteral, Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByStringLiteral, Swift.ExpressibleByArrayLiteral, Swift.ExpressibleByDictionaryLiteral {
  public init(nilLiteral: ())
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Any...)
  public init(dictionaryLiteral elements: (Swift.AnyHashable, Any)...)
  public typealias BooleanLiteralType = Swift.Bool
  public typealias IntegerLiteralType = Swift.Int
  public typealias FloatLiteralType = Swift.Double
  public typealias StringLiteralType = Swift.String
  public typealias ArrayLiteralElement = Any
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Array {
  public func appending(_ newElement: Element) -> [Element]
  public func removing(at index: Swift.Int) -> [Element]
  public mutating func move(at index: Swift.Array<Element>.Index, to newIndex: Swift.Array<Element>.Index)
  public subscript(safe index: Swift.Array<Element>.Index) -> Element? {
    get
  }
}
extension Array where Element : Swift.Equatable {
  public mutating func move(_ item: Element, to newIndex: Swift.Array<Element>.Index)
  public mutating func moveToStart(item: Element)
  public mutating func moveToEnd(item: Element)
}
public struct AnyDecodable : Swift.Decodable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension AnyDecodable : Swift.Equatable {
  public static func == (lhs: CheetahLoyaltyUtils.AnyDecodable, rhs: CheetahLoyaltyUtils.AnyDecodable) -> Swift.Bool
}
extension AnyDecodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyDecodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Bundle {
  public static var CheetahLoyaltyUtilsIdentifier: Swift.String {
    get
  }
  public static var cheetahBundles: [Foundation.Bundle] {
    get
  }
  public static var testBundle: Foundation.Bundle? {
    get
  }
  public static func bundle(forResource resource: Swift.String?, withExtension resourceExtension: Swift.String?) -> Foundation.Bundle?
  public static func bundle(forFileName fileName: Swift.String) -> Foundation.Bundle?
}
extension String {
  public var localized: Swift.String {
    get
  }
}
public enum Localizer {
  public static var languageOptions: [(code: Swift.String, name: Swift.String)] {
    get
  }
  public static var defaultLanguage: Swift.String {
    get
  }
  public static var currentLanguage: Swift.String {
    get
  }
  public static func getLocalizedVersion(ofString string: Swift.String, in bundle: Foundation.Bundle) -> Swift.String
  public static func stringFor(key: Swift.String) -> Swift.String
  public static func getDisplayNameForLanguage(_ language: Swift.String) -> Swift.String
  public static func setCurrentLanguage(_ language: Swift.String)
  public static func resetCurrentLanguageToDefault()
}
public struct KeychainError : Swift.Error {
  public var status: Darwin.OSStatus
  public var localizedDescription: Swift.String {
    get
  }
}
public struct KeychainItem {
  public let serviceName: Swift.String
  public let account: Swift.String
  public init(serviceName: Swift.String, account: Swift.String)
  public static var accessControlWithUserPrescence: Security.SecAccessControl? {
    get
  }
  public func read(context: LocalAuthentication.LAContext? = nil, message: Swift.String? = nil) throws -> Foundation.Data?
  public func readPassword(context: LocalAuthentication.LAContext? = nil, message: Swift.String? = nil) throws -> Swift.String?
  public func readJSON(context: LocalAuthentication.LAContext? = nil, message: Swift.String? = nil) throws -> [Swift.String : Any]?
  public func write(data: Foundation.Data, with access: Security.SecAccessControl? = nil, context: LocalAuthentication.LAContext? = nil) throws
  public func writePassword(_ password: Swift.String, with access: Security.SecAccessControl? = nil, context: LocalAuthentication.LAContext? = nil) throws
  public func write(json: [Swift.String : Any], with access: Security.SecAccessControl? = nil, context: LocalAuthentication.LAContext? = nil) throws
  public func delete() throws
  public func keychainQuery() -> [Swift.String : Any]
}
extension JSONDecoder {
  public func decode<T>(_ type: T.Type, from data: Foundation.Data, keyPath: Swift.String) throws -> T where T : Swift.Decodable
}
extension DateFormatter {
  convenience public init(format: Swift.String? = nil, timeZone: Foundation.TimeZone? = .current, locale: Foundation.Locale? = Locale(identifier: "en_US_POSIX"))
}
public enum Reachability {
  public static func isConnectedToNetwork() -> Swift.Bool
}
public struct AnyCodable : Swift.Codable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension AnyCodable : Swift.Equatable {
  public static func == (lhs: CheetahLoyaltyUtils.AnyCodable, rhs: CheetahLoyaltyUtils.AnyCodable) -> Swift.Bool
}
extension AnyCodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyCodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AnyCodable : Swift.ExpressibleByNilLiteral, Swift.ExpressibleByBooleanLiteral, Swift.ExpressibleByIntegerLiteral, Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByStringLiteral, Swift.ExpressibleByArrayLiteral, Swift.ExpressibleByDictionaryLiteral {
  public init(nilLiteral: ())
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Any...)
  public init(dictionaryLiteral elements: (Swift.AnyHashable, Any)...)
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
  public typealias ArrayLiteralElement = Any
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
  public typealias BooleanLiteralType = Swift.Bool
}
extension String {
  public var youtubeId: Swift.String? {
    get
  }
  public var firstUrl: Foundation.URL? {
    get
  }
  public func firstMatchForRegEx(_ pattern: Swift.String) -> Swift.String?
  public var attributedHTMLString: Foundation.NSAttributedString? {
    get
  }
  public var strippedCSS: Swift.String {
    get
  }
  public var strippedHTML: Swift.String {
    get
  }
  public var isValidURL: Swift.Bool {
    get
  }
  public var isValidEmail: Swift.Bool {
    get
  }
  public var isValidPhoneNumber: Swift.Bool {
    get
  }
  public var isBlank: Swift.Bool {
    get
  }
  public static func createPeriod(startDate: Swift.String, endDate: Swift.String, dateFormat: Swift.String, resultFormat: Swift.String) -> Swift.String
}
extension UIDevice {
  public static var deviceNamesList: [Swift.String : Swift.String] {
    get
  }
  public static var name: Swift.String {
    get
  }
}
extension CheetahLoyaltyUtils.HTTPMethod : Swift.Equatable {}
extension CheetahLoyaltyUtils.HTTPMethod : Swift.Hashable {}
extension CheetahLoyaltyUtils.HTTPMethod : Swift.RawRepresentable {}
extension CheetahLoyaltyUtils.ParameterEncoding : Swift.Equatable {}
extension CheetahLoyaltyUtils.ParameterEncoding : Swift.Hashable {}
extension CheetahLoyaltyUtils.UtilsNotification : Swift.Equatable {}
extension CheetahLoyaltyUtils.UtilsNotification : Swift.Hashable {}
